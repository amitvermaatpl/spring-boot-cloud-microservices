### About this Micro-Service ###

1. Create: Simple micro-service from which we can get the product details. (Boot Project running on 8181)

2. CONFIGURATION: In this service we are going to fetch configuration values from spring-config-server.
   (Boot project running on port 8888) http://localhost:8888/catalog-service/default

3. REGISTER & DISCOVERY: Let us make this service as a Eureka Client and register with the Eureka Server
   (Boot Project running on port 8761).
   
   We just need to add eureka dependency in pom.xml and configure eureka-client property in application.properties
   [eureka.client.service-url.defaultZone=http://localhost:8761/eureka/] to automatically register with the Eureka Server.
   
4. With this configuration in place, start eureka service(coud-service-registry) and then start catalog-service and visit 
   http://localhost:8761
   You should see catalog-service is registered with SERVICE ID as CATALOG-SERVICE. You can also notice the status as UP(1) 
   which means the services are up and running and one instance of catalog-service is running.
  
5. TEST-Service:-  http://localhost:8181/api/products              http://localhost:8181/api/products/P001

6. Let us start another instance of catalog-service on a different port using the following command.
	
   java -jar -Dserver.port=9797 catalog-service-0.0.1-SNAPSHOT.jar

   Now if you go to http://localhost:8761 you will notice that 2 instances of catalog-service got registered and 
   you can see their host-name: port details as well.
      
   http://localhost:9797/api/products 				http://localhost:9797/api/products/P001
   
###===### INVOKE "inventory-service" from this service: MODIFY the Catalog-Service ###===###

We can use RestTemplate to invoke REST endpoint but there are 2 instances running.

We can register RestTemplate as a Spring bean with @LoadBalanced annotation. The RestTemplate with @LoadBalanced annotation 
will internally use Ribbon LoadBalancer to resolve the ServiceID and invoke REST endpoint using one of the available servers.

CONCEPT:= In ProductService.findProductByCode()
Note that we have used http://inventory-service/api/inventory/{code} instead of
http://localhost:9898/api/inventory/{code} or http://localhost:9999/api/inventory/{code} directly.

With this kind of automatic *Service Registration and Discovery mechanism*, we no need to worry about how many instances
are running and what are their hostnames and ports etc.

#####===#####  Spring Cloud Circuit Breaker using Netflix Hystrix #####===##### 
In the microservices world, to fulfill a client request one microservice may need to talk to other microservices. 
We should minimize this kind of direct dependencies on other microservices but in some cases it is unavoidable. 
If a microservice is down or not functioning properly then the issue may cascade up to the upstream services. Netflix 
created Hystrix library implementing Circuit Breaker pattern to address these kinds of issues.

*Implement: Spring Cloud Netflix Hystrix Circuit Breaker to protect microservices from cascading failures.*

From catalog-service we are invoking REST endpoint on inventory-service to get the inventory level of a product. 
What if inventory-service is down? What if inventory-service is taking too long to respond thereby slowing down all 
the services depending on it? We would like to have some timeouts and implement some fallback mechanism.

Reference: https://sivalabs.in/2018/03/spring-cloud-netflix-circuit-breaker/

# TEST Circuit-Breaker #
1. Use @EnableCircuitBreaker and @EnableHystrixDashboard in your Application class.
2. Open browser: http://localhost:8181/hystrix
   In Hystrix Dashboard enter the url: http://localhost:8181/actuator/hystrix.stream
   Then click - Monitor Stream 
3. Now invoke the catalog-service REST endpoint which internally invokes inventory-service REST endpoint 
   and you can see the Circuit status along with how many calls succeed and how many failures occurred etc.
